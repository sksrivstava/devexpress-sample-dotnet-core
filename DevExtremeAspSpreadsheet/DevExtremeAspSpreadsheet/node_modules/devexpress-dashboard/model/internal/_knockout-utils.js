/**
* DevExpress Dashboard (_knockout-utils.js)
* Version:  20.1.6
* Build date: Jul 17, 2020
* Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var custom_store_1 = require("devextreme/data/custom_store");
var data_source_1 = require("devextreme/data/data_source");
var ko = require("knockout");
function subscribeArrayChange(array, handlers) {
    return array.subscribe(function (changes) {
        changes.forEach(function (arrayChange) {
            var change = arrayChange;
            if (change.status === 'added' && handlers.added) {
                handlers.added(change.value, change.index);
            }
            if (change.status === 'deleted' && handlers.deleted) {
                handlers.deleted(change.value);
            }
        });
    }, null, 'arrayChange');
}
exports.subscribeArrayChange = subscribeArrayChange;
function subscribeWithPrev(target, callback) {
    var prevValue;
    var disposables = [];
    disposables.push(target.subscribe(function (value) {
        prevValue = value;
    }, null, 'beforeChange'));
    disposables.push(target.subscribe(function (value) {
        callback(prevValue, value);
        prevValue = undefined;
    }));
    return disposables;
}
exports.subscribeWithPrev = subscribeWithPrev;
function syncArrayHelper(sourceArray, destArray, addHandler) {
    destArray(sourceArray.peek().map(function (item) { return addHandler(item); }));
    return sourceArray.subscribe(function (changes) {
        changes.forEach(function (arrayChange) {
            var change = arrayChange;
            if (change.status === 'added') {
                destArray.splice(change.index, 0, addHandler(change.value));
            }
            else if (change.status === 'deleted') {
                destArray.splice(change.index, 1);
            }
        });
    }, null, 'arrayChange');
}
exports.syncArrayHelper = syncArrayHelper;
function subscribeToArrayItemProperties(array, handler) {
    var subscriptionInfoList = [];
    var subscribe = function (item) {
        subscriptionInfoList.push({ object: item, subscriptions: [].concat(handler(item) || []) });
    };
    var unsubscribe = function (item) {
        var info = subscriptionInfoList.filter(function (info) { return info.object === item; })[0];
        if (info) {
            info.subscriptions.forEach(function (subscription) { return subscription.dispose(); });
            subscriptionInfoList.splice(subscriptionInfoList.indexOf(info), 1);
        }
    };
    array().forEach(subscribe);
    var arrayChangeSubscribtion = subscribeArrayChange(array, {
        added: subscribe,
        deleted: unsubscribe
    });
    return {
        dispose: function () {
            arrayChangeSubscribtion.dispose();
            arrayChangeSubscribtion = null;
            subscriptionInfoList.forEach(function (info) { return info.subscriptions.forEach(function (subscription) { return subscription.dispose(); }); });
            subscriptionInfoList.splice(0, subscriptionInfoList.length);
        }
    };
}
exports.subscribeToArrayItemProperties = subscribeToArrayItemProperties;
function subscribeAndPerform(subscribable, action) {
    action(subscribable());
    return subscribable.subscribe(action);
}
exports.subscribeAndPerform = subscribeAndPerform;
function safeSubscribe(observables, handler) {
    var computed = ko.pureComputed(function () { return Object.keys(observables).reduce(function (acc, key) { acc[key] = observables[key](); return acc; }, {}); });
    var prevDisposable = handler(computed());
    var subscription = computed.subscribe(function (args) {
        prevDisposable && prevDisposable.dispose();
        prevDisposable = handler(args);
    });
    return {
        dispose: function () {
            subscription.dispose();
            computed.dispose();
            prevDisposable && prevDisposable.dispose();
        }
    };
}
exports.safeSubscribe = safeSubscribe;
function safeComputed(observables, handler) {
    var observable = ko.observable();
    var subscription = safeSubscribe(observables, function (args) {
        observable(handler(args));
    });
    var computed = ko.pureComputed(function () { return observable(); });
    var oldDispose = computed.dispose;
    computed.dispose = function () {
        subscription.dispose();
        oldDispose.call(computed);
    };
    return computed;
}
exports.safeComputed = safeComputed;
function createObservableDataSource(observables, load) {
    var computed = ko.pureComputed(function () { return Object.keys(observables).reduce(function (acc, key) { acc[key] = observables[key](); return acc; }, {}); });
    var dataSource = new data_source_1.default({
        store: new custom_store_1.default({
            loadMode: 'raw',
            load: function () { return load(computed()); }
        })
    });
    var subscription = computed.subscribe(function (_) {
        dataSource.reload();
    });
    return {
        dataSource: dataSource,
        dispose: function () {
            subscription.dispose();
            if (dataSource['_disposed'] !== true)
                dataSource.dispose();
            computed.dispose();
        }
    };
}
exports.createObservableDataSource = createObservableDataSource;
