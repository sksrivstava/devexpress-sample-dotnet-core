/**
* DevExpress Dashboard (_aggregated-data-source.js)
* Version:  20.1.6
* Build date: Jul 17, 2020
* Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _item_data_tuple_1 = require("../../../data/item-data/_item-data-tuple");
var _default_1 = require("../../../data/localization/_default");
var _utils_1 = require("../../../data/_utils");
var _date_filter_element_1 = require("../../../viewer-parts/viewer-items/filter-items/_date-filter-element");
var _inspected_data_colum_generator_1 = require("./_inspected-data-colum-generator");
function _createDimensionColumnInfo(dimension, axisName) {
    return {
        getValue: function (row) {
            var point = row.getAxisPoint(axisName);
            if (point) {
                var dimensionValue = point.getDimensionValue(dimension.id);
                if (dimensionValue) {
                    return {
                        displayValue: dimensionValue.getDisplayText(),
                        value: dimensionValue.getUniqueValue()
                    };
                }
            }
            return null;
        },
        getGridColumn: function () {
            return {
                dataField: dimension.id,
                caption: dimension.name || dimension.dataMember || dimension.id,
                calculateCellValue: function (row) { return row[dimension.id] && row[dimension.id].value; }
            };
        }
    };
}
function _createMeasureColumnInfo(itemData, measure, isSparklineMeasure) {
    var sparklineColumnId = '_Sparkline';
    var getSparklineCellText = function (defaultAxisPoint) {
        var argumentValueSeparator = _default_1.getLocalizationById('DashboardStringId.SparklineArgumentValueSeparator');
        var valuesSeparator = _default_1.getLocalizationById('DashboardStringId.SparklineValuesSeparator');
        return itemData
            .getAxis('Sparkline')
            .getPoints()
            .map(function (sparklinePoint) {
            var measureValue = itemData.getSlice(sparklinePoint).getSlice(defaultAxisPoint).getMeasureValue(measure.id);
            if (measureValue) {
                return sparklinePoint.getDisplayText() + argumentValueSeparator + measureValue.getDisplayText();
            }
            return '';
        })
            .join(valuesSeparator);
    };
    return {
        getValue: function (row) {
            if (isSparklineMeasure && itemData.getAxisNames().indexOf('Sparkline') !== -1) {
                var cellText = getSparklineCellText(row.getAxisPoint());
                return { displayValue: cellText, value: cellText };
            }
            return {
                displayValue: itemData.getSlice(row).getMeasureValue(measure.id).getDisplayText(),
                value: itemData.getSlice(row).getMeasureValue(measure.id).getValue()
            };
        },
        getGridColumn: function () {
            var dataField = !isSparklineMeasure ? measure.id : measure.id + sparklineColumnId;
            var caption = measure.name || measure.dataMember || measure.id;
            switch (measure.id) {
                case _date_filter_element_1.dateFilterElement.MinMeasureId:
                    caption += ' ' + _default_1.getLocalizationById('DashboardStringId.StartDate');
                    break;
                case _date_filter_element_1.dateFilterElement.MaxMeasureId:
                    caption += ' ' + _default_1.getLocalizationById('DashboardStringId.EndDate');
                    break;
            }
            return {
                dataField: dataField,
                caption: caption,
                calculateCellValue: function (row) { return row[dataField] && row[dataField].value; }
            };
        }
    };
}
function _createColumns(itemData, axes, args) {
    return axes
        .reduce(function (acc, axis) {
        var distinctDimensions = _utils_1.distinct(itemData.getDimensions(axis), function (dim1, dim2) { return dataInspectorItemDataDimensionComparer(dim1, dim2, itemData); });
        return acc.concat(distinctDimensions.map(function (dimension) { return _createDimensionColumnInfo(dimension, axis); }));
    }, [])
        .concat(_utils_1.distinct(_inspected_data_colum_generator_1.getMeasureColumns(itemData), function (m1, m2) { return dataInspectorItemDataMeasureComparer(m1, m2, itemData, args.addSparklineTotal, args.sparklineMeasures); })
        .reduce(function (acc, measure) {
        var isSparklineMeasure = args.sparklineMeasures != null && args.sparklineMeasures.indexOf(measure.id) !== -1;
        acc.push(_createMeasureColumnInfo(itemData, measure, isSparklineMeasure));
        if (isSparklineMeasure && args.addSparklineTotal) {
            acc.push(_createMeasureColumnInfo(itemData, measure, false));
        }
        return acc;
    }, []));
}
function _createRows(itemData, axes) {
    if (axes.length) {
        return itemData
            .getAxis(axes[0])
            .getAvaliableLeafPoints()
            .reduce(function (acc, primaryAxisPoint) {
            if (axes.length > 1) {
                acc = acc.concat(itemData
                    .getAxis(axes[1])
                    .getAvaliableLeafPoints()
                    .map(function (secondaryAxisPoint) { return new _item_data_tuple_1.itemDataTuple([primaryAxisPoint, secondaryAxisPoint]); }));
            }
            else {
                acc.push(new _item_data_tuple_1.itemDataTuple([primaryAxisPoint]));
            }
            return acc;
        }, []);
    }
    else {
        var defaultAxis = itemData.getAxisNames()[0];
        var axisPoints = defaultAxis ? [itemData.getAxis(defaultAxis).getRootPoint()] : [];
        return [new _item_data_tuple_1.itemDataTuple(axisPoints)];
    }
}
function generateAggregatedSource(itemData, args) {
    if (itemData && !itemData.isEmpty()) {
        var axes = _inspected_data_colum_generator_1.getSortedAxes(itemData, true);
        var columnsInfo_1 = _createColumns(itemData, axes, args);
        var rows = _createRows(itemData, axes);
        return {
            columns: columnsInfo_1.map(function (columnInfo) { return columnInfo.getGridColumn(); }),
            customizeColumns: function () { },
            data: rows.map(function (row) {
                return columnsInfo_1.reduce(function (acc, columnInfo) {
                    acc[columnInfo.getGridColumn().dataField] = columnInfo.getValue(row);
                    return acc;
                }, {});
            })
        };
    }
    return {
        columns: [],
        customizeColumns: function () { },
        data: []
    };
}
exports.generateAggregatedSource = generateAggregatedSource;
function dataInspectorItemDataDimensionComparer(x, y, data) {
    return x.name === y.name
        && x.dataMember === y.dataMember
        && x.dateTimeGroupInterval === y.dateTimeGroupInterval
        && x.textGroupInterval === y.textGroupInterval
        && _utils_1.deepStrictEquals(data.getDimensionFormat(x.id), data.getDimensionFormat(y.id));
}
exports.dataInspectorItemDataDimensionComparer = dataInspectorItemDataDimensionComparer;
function dataInspectorItemDataMeasureComparer(x, y, data, addSparklineTotal, sparklineMeasures) {
    return x.name === y.name
        && x.dataMember == y.dataMember
        && (addSparklineTotal ||
            !sparklineMeasures || ((sparklineMeasures.indexOf(x.id) !== -1) === (sparklineMeasures.indexOf(y.id) !== -1)))
        && ((_utils_1.type.isDefined(data.getMeasureExpression(x.id)) || _utils_1.type.isDefined(data.getMeasureExpression(y.id))) ?
            (data.getMeasureExpression(x.id) === data.getMeasureExpression(y.id)) : (x.summaryType === y.summaryType))
        && _utils_1.deepStrictEquals(data.getMeasureCalculation(x.id), data.getMeasureCalculation(y.id))
        && _utils_1.deepStrictEquals(data.getMeasureWindowDefinition(x.id), data.getMeasureWindowDefinition(y.id))
        && _utils_1.deepStrictEquals(data.getMeasureFormat(x.id), data.getMeasureFormat(y.id));
}
exports.dataInspectorItemDataMeasureComparer = dataInspectorItemDataMeasureComparer;
