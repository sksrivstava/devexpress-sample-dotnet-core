/**
* DevExpress Dashboard (_chart-data-controller-proto.js)
* Version:  20.1.6
* Build date: Jul 17, 2020
* Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var enums_1 = require("../../model/enums");
var _item_data_axis_names_1 = require("../../viewer-parts/viewer/_item-data-axis-names");
var _render_helper_1 = require("../../viewer-parts/widgets/_render-helper");
var special_values_1 = require("../special-values");
var _chart_helper_1 = require("../_chart-helper");
var _common_1 = require("../_common");
var _formatter_1 = require("../_formatter");
var _localization_ids_1 = require("../_localization-ids");
var _localizer_1 = require("../_localizer");
var _utils_1 = require("../_utils");
var _chart_data_controller_base_1 = require("./_chart-data-controller-base");
var chartDataControllerProto = (function (_super) {
    __extends(chartDataControllerProto, _super);
    function chartDataControllerProto(options) {
        var _this = _super.call(this, options) || this;
        _this._legendSeriesPrefix = '__legend__series__';
        _this._argumentAxisPoints = _this.getArgumentAxisPoints();
        return _this;
    }
    chartDataControllerProto.prototype.getLegendSeriesName = function (seriesName) {
        return this._legendSeriesPrefix + seriesName;
    };
    chartDataControllerProto.prototype.getLegendSeriesDisplayName = function (seriesName) {
        return seriesName.indexOf(this._legendSeriesPrefix) !== -1 ? seriesName.replace(this._legendSeriesPrefix, '') : seriesName;
    };
    chartDataControllerProto.prototype.getDataSourceAndSeries = function (encodeHtml) {
        var _this = this;
        var that = this;
        if (!that.viewModel || that._argumentAxisPoints.length == 0) {
            return {
                dataSource: null,
                series: null,
                argumentAxis: {
                    categories: []
                }
            };
        }
        var seriesInfoList = that._getSeriesInfo(encodeHtml), legendInfoList = that.viewModel.Legend ? that._getLegendInfo() : [], result = {
            dataSource: [],
            series: [],
            argumentAxis: null
        };
        var dataSourceAndCategories = this.getDataSourceAndCategories(seriesInfoList);
        if (dataSourceAndCategories) {
            result.dataSource = dataSourceAndCategories.dataSource;
            if (dataSourceAndCategories.categories)
                result.argumentAxis = { categories: dataSourceAndCategories.categories };
        }
        if (seriesInfoList.length > 0) {
            seriesInfoList.forEach(function (seriesInfo) {
                if (seriesInfo.seriesItem) {
                    result.series.push(seriesInfo.seriesItem);
                }
            });
            legendInfoList.forEach(function (legendInfo) {
                result.series.push({
                    name: _this.getLegendSeriesName(legendInfo.name),
                    color: legendInfo.color,
                    type: legendInfo.type
                });
            });
        }
        return result;
    };
    chartDataControllerProto.prototype.getDataSourceAndCategories = function (seriesInfoList) {
        return this.getDataDefinedDataSourceAndCategories(seriesInfoList);
    };
    chartDataControllerProto.prototype.getDataDefinedDataSourceAndCategories = function (seriesInfoList) {
        var _this = this;
        var dataSource = [];
        var categories;
        if (seriesInfoList.length > 0) {
            categories = [];
            this._argumentAxisPoints.forEach(function (argumentAxisPoint, pointIndex) {
                var argument = _this.getArgumentBindingValue(argumentAxisPoint, pointIndex), dataSourceItem = {
                    x: argument
                };
                if (_this._isSelectionTagsRequired()) {
                    dataSourceItem.tag = {
                        axisPoint: argumentAxisPoint
                    };
                }
                if (_this.isDiscreteArgument()) {
                    categories.push(argument);
                }
                seriesInfoList.forEach(function (seriesInfo) {
                    if (seriesInfo.originalSeriesType === 'HighLowClose') {
                        dataSourceItem.nullColumn = null;
                    }
                    seriesInfo.valueFields.forEach(function (valueField) {
                        var value = valueField.getValue(argumentAxisPoint);
                        if (value === special_values_1.specialValues.errorValueGuid)
                            value = 0;
                        dataSourceItem[valueField.name] = value;
                    });
                });
                dataSource.push(dataSourceItem);
            });
        }
        else {
            categories = undefined;
        }
        return {
            dataSource: dataSource,
            categories: categories
        };
    };
    chartDataControllerProto.prototype.generatePaneName = function (paneName, paneIndex) {
        return paneName || 'Pane ' + paneIndex;
    };
    chartDataControllerProto.prototype._getSeriesInfo = function (encodeHtml) {
        var info;
        var that = this, seriesIndex = 0, seriesAxisPoints = this.getSeriesAxisPoints(), isGrandTotal = !this.viewModel.SummarySeriesMember, includeTags = that._isSelectionTagsRequired(), reversed = this.viewModel.AxisX && this.viewModel.AxisX.Reverse, result = [], add = function (info) {
            var canReverse = info.seriesItem.type !== 'stackedbar' && info.seriesItem.type !== 'fullstackedbar';
            if (reversed && canReverse)
                result.unshift(info);
            else
                result.push(info);
        };
        that._iterateSeriesTemplates(function (pane, seriesTemplate, paneIndex) {
            var paneName = pane ? that.generatePaneName(pane.Name, paneIndex) : undefined, specifyTitleByName = pane ? pane.SpecifySeriesTitlesWithSeriesName : false, pointLabelInfo = that._getPointLabelInfo(seriesTemplate.PointLabel);
            seriesAxisPoints.forEach(function (seriesAxisPoint) {
                info = {
                    name: seriesTemplate.Name,
                    dataId: seriesTemplate.DataId,
                    paneName: paneName,
                    pointVisible: that._showPointMarker(seriesTemplate),
                    seriesType: _chart_helper_1.chartHelper.convertSeriesType(seriesTemplate.SeriesType),
                    originalSeriesType: seriesTemplate.SeriesType,
                    plotOnSecondaryAxis: seriesTemplate.PlotOnSecondaryAxis,
                    ignoreEmptyPoints: seriesTemplate.IgnoreEmptyPoints,
                    axisPoint: seriesAxisPoint,
                    dataMembers: seriesTemplate.DataMembers,
                    colorMeasureId: seriesTemplate.ColorMeasureID,
                    valueFormats: [],
                    valueFields: [],
                    pointLabel: pointLabelInfo
                };
                info.dataMembers.forEach(function (dataMember) {
                    info.valueFormats.push(that.multiData.getMeasureFormat(dataMember));
                    info.valueFields.push({
                        name: 'y' + seriesIndex.toString(),
                        getValue: function (argumentAxisPoint) {
                            return that._getCrossSlice(argumentAxisPoint, seriesAxisPoint).getMeasureValue(dataMember).getValue();
                        }
                    });
                    seriesIndex++;
                });
                if (!isGrandTotal) {
                    info.title = that.getTitle(seriesAxisPoint);
                    if (specifyTitleByName) {
                        info.title += ' - ' + seriesTemplate.Name;
                    }
                }
                else {
                    info.title = seriesTemplate.Name;
                }
                info.seriesItem = that._createSeriesItem(info, includeTags, encodeHtml);
                add(info);
            });
        });
        return result;
    };
    chartDataControllerProto.prototype.customizeTooltipText = function (series, point, seriesFormats, encodeHtml) {
        if (!this._validatePoint(point, series.type))
            return null;
        var color = this._getCustomizeTooltipTextColor(point);
        return this._getTooltipHtml(series, point, seriesFormats, encodeHtml, color);
    };
    chartDataControllerProto.prototype._getTooltipHtml = function (series, point, seriesFormats, encodeHtml, color) {
        var text = this._getTooltipTextInternal(series, point, seriesFormats, encodeHtml);
        if (color) {
            text = '<div>' + _render_helper_1.RenderHelper.rectangle(color, 10, 10) + '&nbsp;&nbsp;' + text + '</div>';
        }
        return text;
    };
    chartDataControllerProto.prototype._getTooltipTextInternal = function (series, point, seriesFormats, encodeHtml) {
        var that = this, text = series.name + ': ';
        text = encodeHtml ? _utils_1.encodeHtml(text) : text;
        switch (series.type) {
            case 'rangebar':
            case 'rangearea':
                text += that._formatValuesList([point.originalMinValue, point.originalValue], seriesFormats, encodeHtml);
                break;
            case 'bubble':
                text += that._formatValuesList([point.originalValue, point.size], seriesFormats, encodeHtml);
                break;
            case 'stock':
            case 'candlestick':
                text += that._formatOpenHighLowCloseValues([point.originalOpenValue, point.originalHighValue, point.originalLowValue, point.originalCloseValue], seriesFormats, series.getOptions().openValueField !== 'nullColumn', encodeHtml, '<br>');
                break;
            default:
                text += that._formatValuesList([point.originalValue], seriesFormats, encodeHtml);
                break;
        }
        return text;
    };
    chartDataControllerProto.prototype.getTooltipArgumentText = function (obj) {
        return this.getArgumentText({ value: obj.originalArgument });
    };
    chartDataControllerProto.prototype.getZoomArguments = function () {
        var that = this, axisX = that.viewModel ? that.viewModel.AxisX : undefined;
        if (axisX && axisX.LimitVisiblePoints && that._argumentAxisPoints.length > axisX.VisiblePointsCount) {
            var endIndex = axisX.VisiblePointsCount - 1;
            return {
                start: that.getArgumentBindingValue(that._argumentAxisPoints[0], 0),
                end: that.getArgumentBindingValue(that._argumentAxisPoints[endIndex], endIndex)
            };
        }
    };
    chartDataControllerProto.prototype.getArgumentUniquePath = function (value) {
        var that = this;
        for (var i = 0; i < that._argumentAxisPoints.length; i++) {
            if (that.getArgument(that._argumentAxisPoints[i]) === value)
                return that._argumentAxisPoints[i].getUniquePath();
        }
    };
    chartDataControllerProto.prototype._getArgumentAutoFormat = function () {
        var that = this, min = 0, max = 1;
        if (that._argumentAxisPoints.length > 0) {
            min = that._argumentAxisPoints[0].getValue();
            max = that._argumentAxisPoints[that._argumentAxisPoints.length - 1].getValue();
        }
        return _formatter_1.getAxisFormat(min, max);
    };
    chartDataControllerProto.prototype._createArgumentFormat = function () {
        var that = this, argumentAxisLabelFormat = undefined, argument = that.viewModel ? that.viewModel.Argument : undefined;
        if (argument && !that.isDiscreteArgument()) {
            argumentAxisLabelFormat = _formatter_1.convertToFormat(argument.AxisXLabelFormat);
            if (that._isNumericDataType(argument.Type)) {
                if (!argumentAxisLabelFormat || !argument.AxisXLabelFormat.NumericFormat) {
                    argumentAxisLabelFormat = that._getArgumentAutoFormat();
                }
                else {
                    if (argument.AxisXLabelFormat.NumericFormat.Unit == 'Auto') {
                        argumentAxisLabelFormat = that._getArgumentAutoFormat();
                    }
                }
                argumentAxisLabelFormat.dateType = null;
            }
            if (argumentAxisLabelFormat) {
                argumentAxisLabelFormat.showTrailingZeros = false;
            }
        }
        else if (that.isSingleArgument()) {
            argumentAxisLabelFormat = that.getSingleArgumentDimensionFormat();
        }
        return argumentAxisLabelFormat;
    };
    chartDataControllerProto.prototype._createAxisXFormat = function () {
        if (this.viewModel.AxisX.Format && (this.viewModel.AxisX.Format.NumericFormat != null || this.viewModel.AxisX.Format.DateTimeFormat != null))
            return _formatter_1.convertToFormat(this.viewModel.AxisX.Format);
        return this.getArgumentFormat();
    };
    chartDataControllerProto.prototype.getArgumentFormat = function () {
        if (this._argumentFormat == null)
            this._argumentFormat = this._createArgumentFormat();
        return this._argumentFormat;
    };
    chartDataControllerProto.prototype.getAxisXFormat = function () {
        if (this._axisXFormat == null)
            this._axisXFormat = this._createAxisXFormat();
        return this._axisXFormat;
    };
    chartDataControllerProto.prototype.getArgumentText = function (argument) {
        var _this = this;
        return this._getArgumentText(argument.value, function () { return _this.getArgumentFormat(); });
    };
    chartDataControllerProto.prototype.getAxisXLabelText = function (axisValue) {
        var _this = this;
        return this._getArgumentText(axisValue.value, function () { return _this.getAxisXFormat(); });
    };
    chartDataControllerProto.prototype._getArgumentText = function (argumentValue, formatGetter) {
        if (this.isDiscreteArgument() || this.isQualitativeArgument()) {
            var axisPoint = this._argumentAxisPoints[argumentValue];
            if (this.viewModel.Argument.AxisXDateTimeFormatSupported)
                return _formatter_1.formatByFormatInfo(axisPoint.getValue(), formatGetter());
            return axisPoint ? this.getTitle(axisPoint, '\n') : argumentValue;
        }
        return _formatter_1.formatByFormatInfo(argumentValue, formatGetter());
    };
    chartDataControllerProto.prototype._validatePoint = function (point, seriesType) {
        switch (seriesType) {
            case 'rangebar':
            case 'rangearea':
                return !(point.originalMinValue === null && point.originalValue === null);
            case 'bubble':
                return !(point.originalValue === null && point.size === null);
            case 'stock':
            case 'candlestick':
                return !(point.originalOpenValue === null && point.originalHighValue === null && point.originalLowValue === null && point.originalCloseValue === null);
            default:
                return !(point.originalValue === null);
        }
    };
    chartDataControllerProto.prototype._getCustomizeTooltipTextColor = function (point) {
        if (point.getColor) {
            return point.getColor();
        }
    };
    chartDataControllerProto.prototype._getLegendInfo = function () {
        var _this = this;
        var that = this, values = [], result = [], colorMeasures = that.multiData.getColorMeasures(), argumentPoints = that.getArgumentAxisPoints(that.viewModel.ArgumentColorDimension), seriesPoints = that.getSeriesAxisPoints(that.viewModel.SeriesColorDimension), includeProc = function (axisPoint) {
            var dim = axisPoint.getDimension();
            return (dim && _this.viewModel.ColorPathMembers && _this.viewModel.ColorPathMembers.indexOf(dim.id) !== -1);
        }, getColorValuesProc = function (axisPoint) {
            return axisPoint.getValuePath(includeProc);
        }, getColorDisplayTextsProc = function (axisPoint) {
            return axisPoint.getDisplayPath(includeProc);
        };
        colorMeasures.forEach(function (colorMeasure) {
            argumentPoints.forEach(function (argumentPoint) {
                seriesPoints.forEach(function (seriesPoint) {
                    var color = that._getColorFromData(argumentPoint, seriesPoint, colorMeasure.id);
                    if (color) {
                        var valueSet = getColorValuesProc(argumentPoint).concat(getColorValuesProc(seriesPoint));
                        var displayTexts = getColorDisplayTextsProc(argumentPoint).concat(getColorDisplayTextsProc(seriesPoint));
                        if (colorMeasure.name) {
                            valueSet.push(colorMeasure);
                            displayTexts.push(colorMeasure.name);
                        }
                        if (!that._valuesContainsValueSet(values, valueSet)) {
                            values.push(valueSet);
                            var colorText = displayTexts.join(' - ');
                            if (!colorText || colorText == '') {
                                colorText = that._getDisplayTextBySeriesTemplates();
                            }
                            var transparentColor = !that.viewModel.ArgumentColorDimension && _chart_helper_1.chartHelper.isTransparentColorType(that._getLastSeriesType(colorMeasure.id));
                            result.push({
                                name: colorText,
                                color: color,
                                type: transparentColor ? 'bubble' : 'line',
                                argumentField: 'legendFakeArgument',
                                valueField: 'legendFakeValue'
                            });
                        }
                    }
                });
            });
        });
        return result;
    };
    chartDataControllerProto.prototype._valuesContainsValueSet = function (values, valueSet) {
        for (var i = 0; i < values.length; i++) {
            if (values[i].length !== valueSet.length)
                continue;
            var equal = true;
            for (var j = 0; j < values[i].length; j++) {
                if (values[i][j] !== valueSet[j]) {
                    equal = false;
                    break;
                }
            }
            if (equal)
                return true;
        }
        return false;
    };
    chartDataControllerProto.prototype._getLastSeriesType = function (colorMeasureId) {
        var panes = this.viewModel.Panes;
        for (var i = panes.length - 1; i >= 0; i--) {
            for (var j = panes[i].SeriesTemplates.length - 1; j >= 0; j--) {
                if (colorMeasureId === panes[i].SeriesTemplates[j].ColorMeasureID) {
                    return _chart_helper_1.chartHelper.convertSeriesType(panes[i].SeriesTemplates[j].SeriesType);
                }
            }
        }
    };
    chartDataControllerProto.prototype._getDisplayTextBySeriesTemplates = function () {
        var displayTexts = [];
        this._iterateSeriesTemplates(function (pane, seriesTemplate, paneIndex, templateIndex) {
            var name = seriesTemplate.Name;
            if (displayTexts.indexOf(name) === -1) {
                displayTexts.push(name);
            }
        });
        return displayTexts.join(', ');
    };
    chartDataControllerProto.prototype._iterateSeriesTemplates = function (proc) {
        this.viewModel.Panes.forEach(function (pane, paneIndex) {
            pane.SeriesTemplates.forEach(function (seriesTemplate) {
                proc(pane, seriesTemplate, paneIndex);
            });
        });
    };
    chartDataControllerProto.prototype._isSelectionTagsRequired = function () {
        return true;
    };
    chartDataControllerProto.prototype._createSeriesItem = function (seriesInfo, includeTags, encodeHtml) {
        var that = this, seriesItem = {
            argumentField: 'x',
            type: seriesInfo.seriesType,
            showInLegend: seriesInfo.seriesType === 'stock' || seriesInfo.seriesType === 'candlestick'
        }, setNamesListProc = function (names) {
            if (seriesInfo.originalSeriesType === 'HighLowClose') {
                seriesItem[names[0]] = 'nullColumn';
                names.splice(0, 1);
            }
            for (var i = 0; i < Math.min(names.length, seriesInfo.valueFields.length); i++) {
                seriesItem[names[i]] = seriesInfo.valueFields[i].name;
            }
        };
        if (_utils_1.type.isDefined(seriesInfo.title)) {
            seriesItem.name = seriesInfo.title;
        }
        if (_utils_1.type.isDefined(seriesInfo.paneName)) {
            seriesItem.pane = seriesInfo.paneName;
        }
        if (includeTags) {
            seriesItem.tag = {
                axisPoint: seriesInfo.axisPoint,
                dataMembers: seriesInfo.dataMembers,
                valueFormats: seriesInfo.valueFormats,
                colorMeasureId: seriesInfo.colorMeasureId
            };
        }
        if (seriesInfo.pointVisible) {
            seriesItem.point = {
                visible: seriesInfo.pointVisible
            };
        }
        seriesItem[_common_1.DashboardDataIdField] = seriesInfo.dataId;
        switch (seriesItem.type) {
            case 'rangebar':
            case 'rangearea':
                setNamesListProc(['rangeValue1Field', 'rangeValue2Field']);
                break;
            case 'bubble':
                setNamesListProc(['valueField', 'sizeField']);
                break;
            case 'stock':
            case 'candlestick':
                setNamesListProc(['openValueField', 'highValueField', 'lowValueField', 'closeValueField']);
                break;
            default:
                setNamesListProc(['valueField']);
                break;
        }
        seriesItem.axis = (seriesInfo.paneName || '') + (seriesInfo.plotOnSecondaryAxis ? 'secondary' : 'primary');
        if (seriesInfo.ignoreEmptyPoints) {
            seriesItem.ignoreEmptyPoints = seriesInfo.ignoreEmptyPoints;
        }
        if (that.showPointLabels(seriesInfo.pointLabel)) {
            var pointLabel = seriesInfo.pointLabel;
            seriesItem.label = {
                visible: true,
                rotationAngle: pointLabel.rotationAngle,
                customizeText: function () {
                    return that._customizePointLabelText(this, pointLabel, seriesInfo);
                }
            };
            if (seriesItem.type === 'bar') {
                seriesItem.label.showForZeroValues = pointLabel.showForZeroValues;
            }
            if (seriesItem.type === 'bar' || seriesItem.type === 'bubble') {
                seriesItem.label.position = pointLabel.position;
            }
            else if (seriesItem.type === 'fullstackedbar') {
                seriesItem.label.position = 'inside';
            }
        }
        var color = undefined;
        if (_utils_1.type.isDefined(seriesInfo.colorMeasureId)) {
            color = that._getColorFromData(that._argumentAxisPoints[0], seriesInfo.axisPoint, seriesInfo.colorMeasureId);
        }
        if (_chart_helper_1.chartHelper.isSeriesColorSupported(seriesItem.type)) {
            var argumentRootAxisPoint = this.multiData.getAxis(_item_data_axis_names_1.itemDataAxisNames.chartArgumentAxis).getRootPoint();
            color = that._getElementCustomColor(argumentRootAxisPoint, seriesInfo.axisPoint, seriesInfo.dataMembers, color);
        }
        if (color) {
            seriesItem.color = color;
        }
        if (_chart_helper_1.chartHelper.isStackedAreaType(seriesItem.type)) {
            seriesItem.opacity = 1;
        }
        return seriesItem;
    };
    chartDataControllerProto.prototype._customizePointLabelText = function (valueContainer, pointLabel, seriesInfo) {
        var that = this, contentType = pointLabel.contentType, formatArgumentProc = function () {
            return that.getArgumentText({ value: valueContainer.argument });
        }, formatValueProc = function () {
            var formats = seriesInfo.valueFormats;
            switch (seriesInfo.seriesType) {
                case 'rangebar':
                case 'rangearea':
                    return that._formatValuesList([valueContainer.value], [formats[valueContainer.index]], false);
                case 'bubble':
                    return that._formatValuesList([valueContainer.value, valueContainer.size], formats, false);
                case 'stock':
                case 'candlestick':
                    return that._formatOpenHighLowCloseValues([valueContainer.openValue, valueContainer.highValue, valueContainer.lowValue, valueContainer.closeValue], formats, seriesInfo.originalSeriesType !== 'HighLowClose', false, '\n\r');
                default:
                    return that._formatValuesList([valueContainer.value], formats, false);
            }
        };
        var hasArgument = (contentType & enums_1.PointLabelContentType.Argument) > 0, hasSeriesName = (contentType & enums_1.PointLabelContentType.SeriesName) > 0, hasValue = (contentType & enums_1.PointLabelContentType.Value) > 0, hasPercent = (contentType & enums_1.PointLabelContentType.Percent) > 0 && this._getPercentSupported(seriesInfo);
        var firstPart = '';
        var secondPart = '';
        var argument = hasArgument ? formatArgumentProc() : '';
        var series = hasSeriesName ? valueContainer.seriesName : '';
        var value = hasValue ? formatValueProc() : '';
        var percent = hasPercent ? _formatter_1.formatPercentValue(valueContainer.percent) : '';
        if (hasArgument) {
            firstPart = hasSeriesName ? argument + " (" + series + ")" : "" + argument;
        }
        else if (hasSeriesName) {
            firstPart = "" + series;
        }
        if (hasValue) {
            secondPart = hasPercent ? value + " (" + percent + ")" : "" + value;
        }
        else if (hasPercent) {
            secondPart = "" + percent;
        }
        return ["" + firstPart, "" + secondPart].filter(function (s) { return s != ''; }).join(': ');
    };
    chartDataControllerProto.prototype._getPercentSupported = function (seriesInfo) {
        var series = ['fullstackedbar', 'fullstackedline', 'fullstackedarea', 'fullstackedsplinearea'];
        return series.indexOf(seriesInfo.seriesType) >= 0;
    };
    chartDataControllerProto.prototype._formatOpenHighLowCloseValues = function (values, formats, hasOpenValueField, encodeHtml, delimiter) {
        var result = '', delimiter = delimiter || ' ', formatsLength = formats ? formats.length : 0, i, formatIndex, valueNames = [
            _localizer_1.localizer.getString(_localization_ids_1.localizationId.OpenCaption),
            _localizer_1.localizer.getString(_localization_ids_1.localizationId.HighCaption),
            _localizer_1.localizer.getString(_localization_ids_1.localizationId.LowCaption),
            _localizer_1.localizer.getString(_localization_ids_1.localizationId.CloseCaption)
        ];
        if (values && (formatsLength > 0) && (formatsLength <= values.length)) {
            for (formatIndex = 0, i = hasOpenValueField ? 0 : 1; formatIndex < formatsLength; formatIndex++, i++) {
                result += delimiter + valueNames[i] + ': ' + this._formatValue(values[i], formats[formatIndex], encodeHtml);
            }
        }
        return result;
    };
    chartDataControllerProto.prototype._formatValuesList = function (valuesList, formats, encodeHtml) {
        var result = '';
        if (formats && formats.length === valuesList.length) {
            for (var i = 0; i < valuesList.length; i++) {
                result = result + (i === 0 ? '' : ' - ') + this._formatValue(valuesList[i], formats[i], encodeHtml);
            }
        }
        return result;
    };
    chartDataControllerProto.prototype._formatValue = function (value, format, encodeHtml) {
        var text = _formatter_1.format(value ? value : 0, format);
        return encodeHtml ? _utils_1.encodeHtml(text) : text;
    };
    chartDataControllerProto.prototype._isNumericDataType = function (type) {
        return type == 'Integer' || type == 'Float' || type == 'Double' || type == 'Decimal';
    };
    chartDataControllerProto.prototype._convertContentType = function (typeModel) {
        return enums_1.parsePointLabelContentType(typeModel);
    };
    chartDataControllerProto.prototype._showPointMarker = function (seriesTemplate) {
        switch (seriesTemplate.SeriesType) {
            case 'Point':
                return true;
            case 'Line':
            case 'StackedLine':
            case 'FullStackedLine':
            case 'StepLine':
            case 'Spline':
            case 'Area':
            case 'StackedArea':
            case 'FullStackedArea':
            case 'StepArea':
            case 'SplineArea':
            case 'StackedSplineArea':
            case 'FullStackedSplineArea':
            case 'RangeArea':
                return seriesTemplate.ShowPointMarkers;
            default:
                false;
        }
    };
    chartDataControllerProto.prototype.checkSeriesTemplatePointLabels = function (seriesTemplateViewModel) {
        return this.showPointLabels(this._getPointLabelInfo(seriesTemplateViewModel.PointLabel));
    };
    chartDataControllerProto.prototype.showPointLabels = function (pointLabelInfo) {
        return pointLabelInfo && pointLabelInfo.contentType != enums_1.PointLabelContentType.None;
    };
    chartDataControllerProto.prototype._getPointLabelInfo = function (pointLabelViewModel) {
        if (pointLabelViewModel) {
            return {
                showPointLabels: pointLabelViewModel.ShowPointLabels,
                rotationAngle: _chart_helper_1.chartHelper.convertPointLabelRotationAngle(pointLabelViewModel.Orientation),
                position: _chart_helper_1.chartHelper.convertPointLabelPosition(pointLabelViewModel.Position),
                showForZeroValues: pointLabelViewModel.ShowForZeroValues,
                contentType: this._convertContentType(pointLabelViewModel.ContentType),
                scatterContent: pointLabelViewModel.ScatterContent
            };
        }
    };
    return chartDataControllerProto;
}(_chart_data_controller_base_1.chartDataControllerBase));
exports.chartDataControllerProto = chartDataControllerProto;
