/**
* DevExpress Dashboard (_entry-editor-model.js)
* Version:  20.1.6
* Build date: Jul 17, 2020
* Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var validation_engine_1 = require("devextreme/ui/validation_engine");
var $ = require("jquery");
var ko = require("knockout");
var _default_1 = require("../../../data/localization/_default");
var color_1 = require("../../../model/color");
var _item_filter_items_provider_1 = require("../../filtering/_item-filter-items-provider");
var _color_scheme_entry_creator_1 = require("./_color-scheme-entry-creator");
var EntryEditorViewModel = (function () {
    function EntryEditorViewModel(colorPalette) {
        var _this = this;
        this.colorPalette = colorPalette;
        this.editEntry = function (dataSourceBrowser, entry, colorByMeasures, availableMeasures, updateEntry, isAutoGenerated) {
            _this.invalidate();
            _this.isAutogenerated(isAutoGenerated);
            _this.updateEntry = updateEntry;
            _this.hasMeasures(colorByMeasures);
            _this.availableMeasures(availableMeasures);
            _this.entryToEdit(entry.clone());
            _this.subscribeObservables();
            if (colorByMeasures) {
                _this.measuresValidationRules = [{
                        type: 'custom',
                        validationCallback: function () {
                            return _this.measureKeys().length > 0;
                        },
                        message: _default_1.getLocalizationById('DashboardWebStringId.Colorization.ValidationSelectMeasure')
                    }];
            }
            var dimensionEditors = [];
            var promises = [];
            _this.dimensionKeys().forEach(function (key) {
                promises.push(dataSourceBrowser
                    .findDataField(entry.definition.dataSource, entry.definition.dataMember, key.definition.dataMember())
                    .done(function (field) {
                    var type = field && _item_filter_items_provider_1.getRealDimensionType(key.definition, field) || 'Unknown';
                    dimensionEditors.push({
                        dimensionKey: key,
                        valueType: type
                    });
                }));
            });
            $.when.apply($, promises).done(function (fields) {
                _this.dimensionEditors(dimensionEditors);
                _this.visible(true);
            });
        };
        this.close = function () {
            _this.visible(false);
            _this.invalidate();
        };
        this.validate = function () {
            var validationGroup = validation_engine_1.default.getGroupConfig(_this._validationGroupName);
            if (!!validationGroup && validationGroup.validate().isValid) {
                _this.dimensionKeys().forEach(function (key, index) { return _this.entryToEdit().dimensionKeys()[index].value.value(key.value.value()); });
                _this.entryToEdit().measureKeys(_this.measureKeys().map(function (key) { return _color_scheme_entry_creator_1.ColorSchemeEntryCreator.createMeasureDefinitionCopy(key); }));
                _this.entryToEdit().paletteIndex(null);
                _this.entryToEdit().color(color_1.Color.fromRgbaString(_this.color()));
                _this.updateEntry(_this.entryToEdit());
            }
        };
        this.invalidate = function () {
            _this._subscriptions.forEach(function (s) { return s.dispose(); });
            _this._subscriptions = [];
            _this.entryToEdit(null);
            _this.isAutogenerated(false);
            _this.measuresValidationRules = [];
            _this.dimensionKeys([]);
            _this.measureKeys([]);
        };
        this.visible = ko.observable(false);
        this.entryToEdit = ko.observable();
        this.isAutogenerated = ko.observable(false);
        this.hasMeasures = ko.observable();
        this.availableMeasures = ko.observableArray();
        this.measuresValidationRules = [];
        this.dimensionEditors = ko.observableArray();
        this.dimensionKeys = ko.observableArray();
        this.measureKeys = ko.observableArray();
        this.selectedMeasuresIds = ko.computed({
            read: function () {
                return _this.measureKeys().map(function (md) { return md._id; });
            },
            write: function (selectedIds) {
                _this.measureKeys(_this.availableMeasures().filter(function (md) { return selectedIds.some(function (id) { return id === md._id; }); }));
            }
        });
        this.color = ko.observable();
        this._subscriptions = [];
        this._validationGroupName = 'newEntry';
    }
    EntryEditorViewModel.prototype.subscribeObservables = function () {
        var _this = this;
        this.entryToEdit().dimensionKeys().forEach(function (key) { return _this.dimensionKeys.push(_color_scheme_entry_creator_1.ColorSchemeEntryCreator.createDimensionKey(key.definition.dataMember(), key.definition.dateTimeGroupInterval(), key.value.type(), key.value.value())); });
        this.measureKeys(this.entryToEdit().measureKeys().map(function (key) { return _color_scheme_entry_creator_1.ColorSchemeEntryCreator.createMeasureDefinitionCopy(key); }));
        var computedColor = this.entryToEdit().paletteIndex() === null ? this.entryToEdit().color() : this.colorPalette()[this.entryToEdit().paletteIndex()];
        this.color(computedColor ? computedColor.toHex() : '');
        this.dimensionKeys().forEach(function (key) {
            _this._subscriptions.push(key.value.value.subscribe(_this.validate));
        });
        this._subscriptions.push(this.measureKeys.subscribe(this.validate));
        this._subscriptions.push(this.color.subscribe(this.validate));
    };
    return EntryEditorViewModel;
}());
exports.EntryEditorViewModel = EntryEditorViewModel;
